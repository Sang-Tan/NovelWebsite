package core.database;

import core.DatabaseObject;

import javax.persistence.*;
import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

public abstract class BaseRepository<T extends DatabaseObject> {
    private final Class<?> ENTITY_CLASS;
    private final DBFieldMapping PRIMARY_KEY_FIELDS;
    private final DBFieldMapping COLUMNS;
    private final DBFieldMapping AUTO_GENERATED_KEY_FIELDS;
    private final String TABLE_NAME;
    private final String INSERT_STRING;


    //region Initialization
    protected BaseRepository() {
        Class<?> clazz = createEmpty().getClass();
        this.ENTITY_CLASS = clazz;
        this.TABLE_NAME = getTableName(clazz);
        this.PRIMARY_KEY_FIELDS = getPrimaryKey(clazz);
        this.COLUMNS = getColumns(clazz);
        this.AUTO_GENERATED_KEY_FIELDS = getAutoGeneratedKeyFields(clazz);
        this.INSERT_STRING = generateInsertString(COLUMNS);
    }

    private String getTableName(Class<?> clazz) {
        Table tableAnnotation = clazz.getAnnotation(Table.class);
        return tableAnnotation.name();
    }

    private DBFieldMapping getPrimaryKey(Class<?> clazz) {
        DBFieldMapping primaryKeys = new DBFieldMapping();
        Field[] fields = clazz.getDeclaredFields();

        for (Field field : fields) {
            if (field.isAnnotationPresent(Id.class)) {
                Column columnAnnotation = field.getAnnotation(Column.class);
                primaryKeys.put(columnAnnotation.name(), field);
            }
        }
        return primaryKeys;
    }

    private DBFieldMapping getColumns(Class<?> clazz) {
        Field[] fields = clazz.getDeclaredFields();
        DBFieldMapping columns = new DBFieldMapping();
        for (Field field : fields) {
            if (field.isAnnotationPresent(Column.class)) {
                Column columnAnnotation = field.getAnnotation(Column.class);
                columns.put(columnAnnotation.name(), field);
            } else if (field.isAnnotationPresent(EmbeddedId.class)) {
                Field[] idFields = field.getType().getDeclaredFields();
                for (Field idField : idFields) {
                    Column columnAnnotation = idField.getType().getAnnotation(Column.class);
                    if (columnAnnotation != null) {
                        columns.put(columnAnnotation.name(), idField);
                    }
                }
            }
        }
        return columns;
    }

    private DBFieldMapping getAutoGeneratedKeyFields(Class<?> clazz) {
        DBFieldMapping autoGeneratedKeyFields = new DBFieldMapping();
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            if (field.isAnnotationPresent(GeneratedValue.class)) {
                Column columnAnnotation = field.getAnnotation(Column.class);
                autoGeneratedKeyFields.put(columnAnnotation.name(), field);
                return autoGeneratedKeyFields;
            }
        }
        if (autoGeneratedKeyFields.size() > 1) {
            throw new RuntimeException("Multiple auto generated key fields are not supported, please check the entity class :" + clazz.getName());
        }
        return autoGeneratedKeyFields;
    }

    private final String generateInsertString(DBFieldMapping fieldToMap) {
        ArrayList<String> columns = new ArrayList<>();
        ArrayList<String> values = new ArrayList<>();
        for (String columnName : fieldToMap.keySet()) {
            columns.add(columnName);
            values.add("?");
        }
        String columnString = String.join(", ", columns);
        String valueString = String.join(", ", values);
        return String.format("INSERT INTO %s (%s) VALUES (%s)", getTableName(), columnString, valueString);
    }

    protected abstract T createEmpty();

    protected String getTableName() {
        return TABLE_NAME;
    }
    //endregion

    /**
     * Get the primary key(in database)  string separated by comma, e.g. "id, name"
     *
     * @return the primary key string
     */
    protected final String getPrimaryKeyString() {
        ArrayList<String> primaryKeysColumnsName = new ArrayList<>();
        for (Field field : PRIMARY_KEY_FIELDS.values()) {
            Column columnAnnotation = field.getAnnotation(Column.class);
            primaryKeysColumnsName.add(columnAnnotation.name());
        }
        return String.join(", ", primaryKeysColumnsName);
    }

    protected final SqlRecord mapRecordByField(DBFieldMapping fields, T object, boolean ignoreNullFields) {
        SqlRecord record = new SqlRecord();
        for (String columnName : fields.keySet()) {
            Field field = fields.get(columnName);
            try {
                PropertyDescriptor propertyDescriptor = new PropertyDescriptor(field.getName(), object.getClass());
                Object fieldValue = propertyDescriptor.getReadMethod().invoke(object);
                if (fieldValue != null) {
                    record.put(columnName, fieldValue);
                } else if (!ignoreNullFields) {
                    record.put(columnName, null);
                }
            } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) {
                throw new RuntimeException(e);
            }
        }
        return record;
    }

    protected final SqlRecord mapRecord(T object, boolean ignoreNullFields) {
        return mapRecordByField(COLUMNS, object, ignoreNullFields);
    }

    protected final SqlRecord getPrimaryKeyMap(T object) {
        return mapRecordByField(PRIMARY_KEY_FIELDS, object, false);
    }

    protected final T mapObject(SqlRecord sqlRecord) throws SQLException {
        T object = createEmpty();
        try {
            for (String columnName : sqlRecord.keySet()) {
                if (COLUMNS.containsKey(columnName)) {
                    Field field = COLUMNS.get(columnName);
                    PropertyDescriptor propertyDescriptor = new PropertyDescriptor(field.getName(), object.getClass());
                    propertyDescriptor.getWriteMethod().invoke(object, sqlRecord.get(columnName));
                } else {
                    throw new SQLException(String.format("Column %s not found in %s", columnName, object.getClass().getName()));
                }
            }
            //TODO : delete this
//            for (int i = 1; i <= metaData.getColumnCount(); i++) {
//                String columnName = metaData.getColumnName(i);
//                if (COLUMNS.containsKey(columnName)) {
//                    Field field = COLUMNS.get(columnName);
//                    PropertyDescriptor propertyDescriptor = new PropertyDescriptor(field.getName(), object.getClass());
//                    propertyDescriptor.getWriteMethod().invoke(object, sqlRecord.getObject(i, field.getType()));
//                } else {
//                    throw new SQLException(String.format("Column %s not found in %s", columnName, object.getClass().getName()));
//                }
//            }
        } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException(e);
        }
        return object;
    }

    protected final List<T> mapObjects(List<SqlRecord> records) throws SQLException {
        List<T> list = new ArrayList<>();
        for (SqlRecord record : records) {
            list.add(mapObject(record));
        }
        return list;
    }

    public final List<T> getAll() throws SQLException {
        String sql = String.format("SELECT * FROM %s", getTableName());
        List<SqlRecord> records = MySQLdb.getInstance().select(sql);
        return mapObjects(records);
    }

    public List<T> getRange(int start, int end) throws SQLException {
        String sql = String.format("SELECT * FROM %s LIMIT %d, %d", getTableName(), start, end);
        List<SqlRecord> records = MySQLdb.getInstance().select(sql);
        return mapObjects(records);
    }

    /**
     * Get the object by auto generated key
     *
     * @param autoGeneratedKeyMap the auto generated key map
     * @param object              the object to be modified with the auto generated key
     * @return the object with auto generated key, this is the same object as the input object,
     * but it is returned for convenience
     * @throws SQLException
     */
    public T getObjectByAutoGeneratedKey(SqlRecord autoGeneratedKeyMap, T object) throws SQLException {
        if (autoGeneratedKeyMap == null) {
            throw new IllegalArgumentException("autoGeneratedKeySet cannot be null");
        }

        //assume that there is only one auto generated key
        Field autoGeneratedField = AUTO_GENERATED_KEY_FIELDS.values().iterator().next();
        try {
            PropertyDescriptor propertyDescriptor =
                    new PropertyDescriptor(autoGeneratedField.getName(), ENTITY_CLASS);

            List<String> autoGeneratedKeyColumns = autoGeneratedKeyMap.getColumns();
            if (autoGeneratedKeyColumns.size() != 1) {
                throw new SQLException("There should be only one auto generated key");
            }
            Object value = autoGeneratedKeyMap.get(autoGeneratedKeyColumns.get(0));
            Class<?> type = propertyDescriptor.getPropertyType();
            propertyDescriptor.getWriteMethod().invoke(object, value);
        } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException(e);
        }

        return object;
    }

    /**
     * Insert a object into the database, note that the input object will be
     * modified to include the auto generated key if there is any
     *
     * @param object the object to insert
     * @return the object used to insert after modification, this is the same object as the input,
     * this implementation is just for convenience
     * @throws SQLException if there is any error when inserting
     */
    public T insert(T object) throws SQLException {
        SqlRecord record = mapRecord(object, true);
        SqlRecord autoGeneratedKeyMap = insert(record);
        if (AUTO_GENERATED_KEY_FIELDS.size() > 0) {
            //assume that there is only one auto generated key
            if (autoGeneratedKeyMap.size() > 0) {
                getObjectByAutoGeneratedKey(autoGeneratedKeyMap, object);
            }
        }
        return object;
    }

    public final Collection<T> insertBatch(Collection<T> objects) throws SQLException {
        for (T object : objects) {
            insert(object);
        }
        return objects;
    }

    /**
     * Insert a record into the database
     *
     * @param record the record to insert
     * @return the auto generated key if there is any, if there is no auto generated key, ResultSet will be empty
     * @throws SQLException if a database access error occurs
     */
    protected final SqlRecord insert(SqlRecord record) throws SQLException {
        int size = record.size();

        //example columnsString = "col1, col2, col3,..."
        List<String> columns = record.getColumns();
        String columnsString = String.join(", ", columns);

        //example valuesString = "?, ?, ?,..."
        String[] values = new String[size];
        Arrays.fill(values, "?");
        String valuesString = String.join(", ", values);


        String sql = String.format("INSERT INTO %s (%s) VALUES (%s)", getTableName(), columnsString, valuesString);

        List<Object> valuesArray = record.getValues(columns);
        return MySQLdb.getInstance().insert(sql, valuesArray);
    }


    public void update(T object) throws SQLException {
        SqlRecord record = mapRecord(object, true);
        excludePrimaryKey(record);
        SqlRecord primaryKeyRecord = getPrimaryKeyMap(object);
        update(record, primaryKeyRecord);
    }

    protected void excludePrimaryKey(SqlRecord record) {
        for (String key : PRIMARY_KEY_FIELDS.keySet()) {
            record.remove(key);
        }
    }

    protected final void update(SqlRecord record, SqlRecord primaryKeyRecord) throws SQLException {
        int size = record.size();

        //=====================UPDATE COLUMNS=====================
        List<String> upColumns = record.getColumns();

        //parameters for the sql statement
        List<Object> parameters = record.getValues(upColumns);

        for (int i = 0; i < size; i++) {
            upColumns.set(i, upColumns.get(i) + " = ?");
        }
        String setsString = String.join(", ", upColumns); //example : "col1 = ?, col2 = ?, col3 = ?,..."

        //=====================PRIMARY KEY SELECT=====================
        List<String> pkColumns = primaryKeyRecord.getColumns();

        //IMPORTANT : DON'T MOVE THE FOLLOWING LINE
        parameters.addAll(primaryKeyRecord.getValues(pkColumns));
        for (int i = 0; i < pkColumns.size(); i++) {
            pkColumns.set(i, pkColumns.get(i) + " = ?");
        }
        String pkSelect = String.join(" AND ", pkColumns);

        String sql = String.format("UPDATE %s SET %s WHERE %s", getTableName(), setsString, pkSelect);

        MySQLdb.getInstance().execute(sql, parameters);
    }

    public void delete(T object) throws SQLException {
        SqlRecord primaryKeyRecord = getPrimaryKeyMap(object);
        delete(primaryKeyRecord);
    }

    protected final void delete(SqlRecord primaryKeyRecord) throws SQLException {
        List<String> pkColumns = primaryKeyRecord.getColumns();
        List<String> pkColumnExpression = new ArrayList<>(pkColumns.size());

        for (int i = 0; i < pkColumns.size(); i++) {
            pkColumnExpression.add(pkColumns.get(i) + " = ?");
        }
        String pkSelect = String.join(" AND ", pkColumnExpression);

        String sql = String.format("DELETE FROM %s WHERE %s", getTableName(), pkSelect);

        MySQLdb.getInstance().execute(sql, primaryKeyRecord.getValues(pkColumns));
    }


    public Integer count() throws SQLException {
        String sql = String.format("SELECT COUNT(%s) as count FROM %s", getPrimaryKeyString(), getTableName());
        List<SqlRecord> records = MySQLdb.getInstance().select(sql);
        if (records.size() > 0) {
            return (Integer) records.get(0).get("count");
        }
        return 0;
    }
}